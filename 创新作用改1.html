<style> .hljs { white-space: pre-wrap !important; word-wrap: break-word !important; } </style>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=yes">
  <style>
body {
  background-color: #ffffff;
}

input[type="checkbox"], input[type="radio"] {
  -webkit-transform: translate(0px) scale(1.15);
  transform: translate(0px) scale(1.15);
}

select:focus {
  outline: none !important;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
}

.markdown-body [type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #007AFF;
  text-decoration: underline;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body h1 {
  font-size: 32px;
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
  font-weight: 600;
}

.markdown-body h3 {
  font-size: 20px;
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
  font-weight: 600;
}

.markdown-body h5 {
  font-size: 14px;
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
  font-weight: 600;
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body code {
  font-family: ui-monospace, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: underline;
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  background: #f9f9f9;
  padding: 0.5em 10px;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body blockquote:before {
  margin-right: 0.25em;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 14px;
  margin-bottom: 16px;
  padding-top: 10px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: 0.875em;
}

.markdown-body h6 {
  font-size: 0.85em;
  color: #6a737d;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: 0.25em;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
}

.markdown-body table th {
  font-weight: 600;
  background-color: #f6f8fa;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body :not(pre)>code {
  padding: 0.14em 0.3em;
  margin: 0;
  font-size: 85%;
  vertical-align: 5%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
  border-width: 1px;
  border-style: solid;
  border-color: #dfe2e5;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  border-radius: 3px;
}

.markdown-body pre {
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  border-radius: 4px;
  border: thin solid #e0e0e0;
}

.markdown-body pre code {
  max-width: auto;
  padding: 16px;
  margin: 0;
  line-height: inherit;
  word-wrap: normal;
  border-radius: 3px;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.2em 0.16em -1.25em;
  vertical-align: middle;
}

.markdown-body .highlighter {
  background-color: rgba(255, 255, 0, 0.8);
}

.no-file-access {
  color: red !important;
  text-decoration: none !important;
}

.syntax-picker {
  margin-left: -4px;
  margin-bottom: 8px;
  width: 100%;
  overflow-x: scroll;
  white-space: nowrap;
}

.syntax-picker::-webkit-scrollbar { 
  display: none;
}

.syntax-light-theme-picker {
  display: inline;
}

.syntax-dark-theme-picker {
  display: none;
}

.toc-item {
  display: inline-block;
  margin-top: 4px;
  margin-bottom: 2px;
  border-bottom: 1px solid #eaecef;
}

.toc-item > a {
  color: #24292e !important;
  text-decoration: none !important;
}

.toc-level-1, .toc-level-2, .toc-level-3 {
  font-weight: 500;
}

.toc-level-1 {
  font-size: 19px;
}

.toc-level-2 {
  font-size: 18px;
}

.toc-level-3 {
  font-size: 17px;
}

.toc-level-4, .toc-level-5, .toc-level-6 {
  font-size: 16px;
}

.embedded-file {
  border: 1px solid;
  border-radius: 4px;
  border-color: #dddddd;
}
</style>
  <style>
body {
  background-color: #0f0f0f;
}

.markdown-body {
  color: #e3e3e3;
}

.markdown-body a {
  color: #0A84FF;
}

.markdown-body hr {
  border-bottom: 1px solid #404040;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4 {
  color: #ffffff;
}

.markdown-body blockquote {
  color: #acacac;
  border-left: 0.25em solid #303030;
  background: #202020;
}

.markdown-body kbd {
  color: #444d56;
  background-color: #fafbfc;
  border: solid 1px #c6cbd1;
  border-bottom-color: #959da5;
  box-shadow: inset 0 -1px 0 #959da5;
}

.markdown-body h1 {
  border-bottom: 1px solid #303030;
}

.markdown-body h2 {
  border-bottom: 1px solid #303030;
}

.markdown-body h5,
.markdown-body h6 {
  color: #6a737d;
}

.markdown-body table th {
  background-color: #292929;
}

.markdown-body table th,
.markdown-body table td {
  border: 1px solid #404040;
}

.markdown-body table tr {
  background-color: #212121;
  border-top: 1px solid #c6cbd1;
  color: #e3e3e3;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #292929;
}

.markdown-body img {
  background-color: #0f0f0f;
}

.markdown-body :not(pre)>code {
  background-color: #292929;
  border-color: #404040;
}

.markdown-body pre {
  border: thin solid #303030;
}

.markdown-body kbd {
  color: #444d56;
  background-color: #fafbfc;
  border: solid 1px #d1d5da;
  border-bottom-color: #c6cbd1;
  box-shadow: inset 0 -1px 0 #c6cbd1;
}

.markdown-body .highlighter {
  background-color: rgba(255, 255, 0, 0.2);
}

.syntax-light-theme-picker {
  display: none;
}

.syntax-dark-theme-picker {
  display: inline;
}

.toc-item {
  border-bottom: 1px solid #404040;
}

.toc-item > a {
  color: #e3e3e3 !important;
}

.embedded-file {
  border-color: #444444;
}
</style>
  <style>
    .markdown-body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 820px;
      margin: 0 auto;
      padding: 15px 45px;
      font-family: "system-ui", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      line-height: 1.5;
    }
    @media (max-width: 767px) {
      .markdown-body {
        padding: 15px;
      }
    }
    @media (min-width: 1024px) {
      .markdown-body {
        transform: scale(1);
        transform-origin: top center;
      }
    }
    .sequence svg, .flowchart svg, .mermaid svg, .plantuml-svg {
      background: white;
      margin-bottom: 24px;
      margin-right: 24px;
      border-radius: 3px;
    }
    .plantuml-svg {
      display: block;
    }
  </style>
  <style>
.hljs{display:block;overflow-x:auto;padding:.5em;color:#ffffff;background:#1c1b1b}.hljs-comment{color:#999999}.hljs-keyword,.hljs-selector-tag,.hljs-meta-keyword,.hljs-doctag,.hljs-section,.hljs-selector-class,.hljs-meta,.hljs-selector-pseudo,.hljs-attr{color:#88aece}.hljs-attribute{color:v#c59bc1}.hljs-name,.hljs-type,.hljs-number,.hljs-selector-id,.hljs-quote,.hljs-template-tag,.hljs-built_in,.hljs-title,.hljs-literal{color:#f08d49}.hljs-string,.hljs-regexp,.hljs-symbol,.hljs-variable,.hljs-template-variable,.hljs-link,.hljs-selector-attr,.hljs-meta-string{color:#b5bd68}.hljs-bullet,.hljs-code{color:#cccccc}.hljs-deletion{color:#de7176}.hljs-addition{color:#76c490}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}
</style>
<script>
  /*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function(factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = typeof window === 'object' && window ||
                     typeof self === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  // `nodeType` is checked to ensure that `exports` is not a HTML element.
  if(typeof exports !== 'undefined' && !exports.nodeType) {
    factory(exports);
  } else if(globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if(typeof define === 'function' && define.amd) {
      define([], function() {
        return globalObject.hljs;
      });
    }
  }

}(function(hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases   = {};

  // safe/production mode - swallows more errors, tries to keep running
  // even if a single syntax or parse hits a fatal error
  var SAFE_MODE = true;

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe    = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe      = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  // The object will be assigned by the build tool. It used to synchronize API
  // of external language files with minified version of the highlight.js library.
  var API_REPLACES;

  var spanEndTag = '</span>';
  var LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  // keywords that should have no default relevance value
  var COMMON_KEYWORDS = 'of and for in not or if then'.split(' ');


  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      var language = getLanguage(match[1]);
      if (!language) {
        console.warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        console.warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  /**
   * performs a shallow merge of multiple objects into one
   *
   * @arguments list of objects with properties to merge
   * @returns a single new object
   */
  function inherit(parent) {  // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent)
      result[key] = parent[key];
    objects.forEach(function(obj) {
      for (key in obj)
        result[key] = obj[key];
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3)
          offset += child.nodeValue.length;
        else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return (original[0].offset < highlighted[0].offset) ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:

      if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;

      ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace(/"/g, '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function dependencyOnParent(mode) {
    if (!mode) return false;

    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }

  function expand_or_clone_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function(variant) {
        return inherit(mode, {variants: null}, variant);
      });
    }

    // EXPAND
    // if we have variants then essentially "replace" the mode with the variants
    // this happens in compileMode, where this function is called from
    if (mode.cached_variants)
      return mode.cached_variants;

    // CLONE
    // if we have dependencies on parents then we need a unique
    // instance of ourselves, so we can be reused with many
    // different parents without issue
    if (dependencyOnParent(mode))
      return [inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null })];

    if (Object.isFrozen(mode))
      return [inherit(mode)];

    // no special dependency issues, just return ourselves
    return [mode];
  }

  function restoreLanguageApi(obj) {
    if(API_REPLACES && !obj.langApiRestored) {
      obj.langApiRestored = true;
      for(var key in API_REPLACES) {
        if (obj[key]) {
          obj[API_REPLACES[key]] = obj[key];
        }
      }
      (obj.contains || []).concat(obj.variants || []).forEach(restoreLanguageApi);
    }
  }

  function compileKeywords(rawKeywords, case_insensitive) {
      var compiled_keywords = {};

      if (typeof rawKeywords === 'string') { // string
        splitAndCompile('keyword', rawKeywords);
      } else {
        objectKeys(rawKeywords).forEach(function (className) {
          splitAndCompile(className, rawKeywords[className]);
        });
      }
    return compiled_keywords;

    // ---

    function splitAndCompile(className, str) {
      if (case_insensitive) {
        str = str.toLowerCase();
      }
      str.split(' ').forEach(function(keyword) {
        var pair = keyword.split('|');
        compiled_keywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }

  function scoreForKeyword(keyword, providedScore) {
    // manual scores always win over common keywords
    // so you can force a score of 1 if you really insist
    if (providedScore)
      return Number(providedScore);

    return commonKeyword(keyword) ? 0 : 1;
  }

  function commonKeyword(word) {
    return COMMON_KEYWORDS.indexOf(word.toLowerCase()) != -1;
  }

  function compileLanguage(language) {

    function reStr(re) {
        return (re && re.source) || re;
    }

    function langRe(value, global) {
      return new RegExp(
        reStr(value),
        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
      );
    }

    function reCountMatchGroups(re) {
      return (new RegExp(re.toString() + '|')).exec('').length - 1;
    }

    // joinRe logically computes regexps.join(separator), but fixes the
    // backreferences so they continue to match.
    // it also places each individual regular expression into it's own
    // match group, keeping track of the sequencing of those match groups
    // is currently an exercise for the caller. :-)
    function joinRe(regexps, separator) {
      // backreferenceRe matches an open parenthesis or backreference. To avoid
      // an incorrect parse, it additionally matches the following:
      // - [...] elements, where the meaning of parentheses and escapes change
      // - other escape sequences, so we do not misparse escape sequences as
      //   interesting elements
      // - non-matching or lookahead parentheses, which do not capture. These
      //   follow the '(' with a '?'.
      var backreferenceRe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      var numCaptures = 0;
      var ret = '';
      for (var i = 0; i < regexps.length; i++) {
        numCaptures += 1;
        var offset = numCaptures;
        var re = reStr(regexps[i]);
        if (i > 0) {
          ret += separator;
        }
        ret += "(";
        while (re.length > 0) {
          var match = backreferenceRe.exec(re);
          if (match == null) {
            ret += re;
            break;
          }
          ret += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] == '\\' && match[1]) {
            // Adjust the backreference.
            ret += '\\' + String(Number(match[1]) + offset);
          } else {
            ret += match[0];
            if (match[0] == '(') {
              numCaptures++;
            }
          }
        }
        ret += ")";
      }
      return ret;
    }

    function buildModeRegex(mode) {

      var matchIndexes = {};
      var matcherRe;
      var regexes = [];
      var matcher = {};
      var matchAt = 1;

      function addRule(rule, regex) {
        matchIndexes[matchAt] = rule;
        regexes.push([rule, regex]);
        matchAt += reCountMatchGroups(regex) + 1;
      }

      var term;
      for (var i=0; i < mode.contains.length; i++) {
        var re;
        term = mode.contains[i];
        if (term.beginKeywords) {
          re = '\\.?(?:' + term.begin + ')\\.?';
        } else {
          re = term.begin;
        }
        addRule(term, re);
      }
      if (mode.terminator_end)
        addRule("end", mode.terminator_end);
      if (mode.illegal)
        addRule("illegal", mode.illegal);

      var terminators = regexes.map(function(el) { return el[1]; });
      matcherRe = langRe(joinRe(terminators, '|'), true);

      matcher.lastIndex = 0;
      matcher.exec = function(s) {
        var rule;

        if( regexes.length === 0) return null;

        matcherRe.lastIndex = matcher.lastIndex;
        var match = matcherRe.exec(s);
        if (!match) { return null; }

        for(var i = 0; i<match.length; i++) {
          if (match[i] != undefined && matchIndexes["" +i] != undefined ) {
            rule = matchIndexes[""+i];
            break;
          }
        }

        // illegal or end match
        if (typeof rule === "string") {
          match.type = rule;
          match.extra = [mode.illegal, mode.terminator_end];
        } else {
          match.type = "begin";
          match.rule = rule;
        }
        return match;
      };

      return matcher;
    }

    function compileMode(mode, parent) {
      if (mode.compiled)
        return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords)
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);

      mode.lexemesRe = langRe(mode.lexemes || /[\\$\w]+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin)
          mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (mode.endSameAsBegin)
          mode.end = mode.begin;
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end)
          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal)
        mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null)
        mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function(c) {
        return expand_or_clone_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function(c) {compileMode(c, mode);});

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      mode.terminators = buildModeRegex(mode);
    }

    // self is not valid at the top-level
    if (language.contains && language.contains.indexOf('self') != -1) {
      if (!SAFE_MODE) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.")
      } else {
        // silently remove the broken rule (effectively ignoring it), this has historically
        // been the behavior in the past, so this removal preserves compatibility with broken
        // grammars when running in Safe Mode
        language.contains = language.contains.filter(function(mode) { return mode != 'self'; });
      }
    }
    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:

  - relevance (int)
  - value (an HTML string with highlighting markup)

  */
  function highlight(name, value, ignore_illegals, continuation) {

    function escapeRe(value) {
      return new RegExp(value.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(className, insideSpan, leaveOpen, noPrefix) {
      if (!leaveOpen && insideSpan === '') return '';
      if (!className) return insideSpan;

      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan    = '<span class="' + classPrefix,
          closeSpan   = leaveOpen ? '' : spanEndTag;

      openSpan += className + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords)
        return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ?
                   highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) :
                   highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Use case in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += (top.subLanguage != null ? processSubLanguage() : processKeywords());
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className? buildSpan(mode.className, '', true): '';
      top = Object.create(mode, {parent: {value: top}});
    }


    function doBeginMatch(match) {
      var lexeme = match[0];
      var new_mode = match.rule;

      if (new_mode && new_mode.endSameAsBegin) {
        new_mode.endRe = escapeRe( lexeme );
      }

      if (new_mode.skip) {
        mode_buffer += lexeme;
      } else {
        if (new_mode.excludeBegin) {
          mode_buffer += lexeme;
        }
        processBuffer();
        if (!new_mode.returnBegin && !new_mode.excludeBegin) {
          mode_buffer = lexeme;
        }
      }
      startNewMode(new_mode);
      return new_mode.returnBegin ? 0 : lexeme.length;
    }

    function doEndMatch(match) {
      var lexeme = match[0];
      var matchPlusRemainder = value.substr(match.index);
      var end_mode = endOfMode(top, matchPlusRemainder);
      if (!end_mode) { return; }

      var origin = top;
      if (origin.skip) {
        mode_buffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          mode_buffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          mode_buffer = lexeme;
        }
      }
      do {
        if (top.className) {
          result += spanEndTag;
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== end_mode.parent);
      if (end_mode.starts) {
        if (end_mode.endSameAsBegin) {
          end_mode.starts.endRe = end_mode.endRe;
        }
        startNewMode(end_mode.starts);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }

    var lastMatch = {};
    function processLexeme(text_before_match, match) {

      var lexeme = match && match[0];

      // add non-matched text to the current mode buffer
      mode_buffer += text_before_match;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      // we've found a 0 width match and we're stuck, so we need to advance
      // this happens when we have badly behaved rules that have optional matchers to the degree that
      // sometimes they can end up matching nothing at all
      // Ref: https://github.com/highlightjs/highlight.js/issues/2140
      if (lastMatch.type=="begin" && match.type=="end" && lastMatch.index == match.index && lexeme === "") {
        // spit the "skipped" character that our regex choked on back into the output sequence
        mode_buffer += value.slice(match.index, match.index + 1);
        return 1;
      }
      lastMatch = match;

      if (match.type==="begin") {
        return doBeginMatch(match);
      } else if (match.type==="illegal" && !ignore_illegals) {
        // illegal match, we do not continue processing
        throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
      } else if (match.type==="end") {
        var processed = doEndMatch(match);
        if (processed != undefined)
          return processed;
      }

      /*
      Why might be find ourselves here?  Only one occasion now.  An end match that was
      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
      rule sets the end rule to a specific match.  Since the overall mode termination rule that's
      being used to scan the text isn't recompiled that means that any match that LOOKS like
      the end (but is not, because it is not an exact match to the beginning) will
      end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
      the end rule and fails to match, we wind up here, and just silently ignore the end.

      This causes no real harm other than stopping a few times too many.
      */

      mode_buffer += lexeme;
      return lexeme.length;
    }

    var language = getLanguage(name);
    if (!language) {
      console.error(LANGUAGE_NOT_FOUND.replace("{}", name));
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '', current;
    for(current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match, count, index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match)
          break;
        count = processLexeme(value.substring(index, match.index), match);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for(current = top; current.parent; current = current.parent) { // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        illegal:false,
        language: name,
        top: top
      };
    } catch (err) {
      if (err.message && err.message.indexOf('Illegal') !== -1) {
        return {
          illegal: true,
          relevance: 0,
          value: escape(value)
        };
      } else if (SAFE_MODE) {
        return {
          relevance: 0,
          value: escape(value),
          language: name,
          top: top,
          errorRaised: err
        };
      } else {
        throw err;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

  */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).filter(autoDetection).forEach(function(name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers

  */
  function fixMarkup(value) {
    if (!(options.tabReplace || options.useBR)) {
      return value;
    }

    return value.replace(fixMarkupRe, function(match, p1) {
        if (options.useBR && match === '\n') {
          return '<br>';
        } else if (options.tabReplace) {
          return p1.replace(/\t/g, options.tabReplace);
        }
        return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result   = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language))
        return;

    if (options.useBR) {
      node = document.createElement('div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElement('div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called)
      return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    window.addEventListener('DOMContentLoaded', initHighlighting, false);
    window.addEventListener('load', initHighlighting, false);
  }

  var PLAINTEXT_LANGUAGE = { disableAutodetect: true };

  function registerLanguage(name, language) {
    var lang;
    try { lang = language(hljs); }
    catch (error) {
      console.error("Language definition for '{}' could not be registered.".replace("{}", name));
      // hard or soft error
      if (!SAFE_MODE) { throw error; } else { console.error(error); }
      // languages that have serious errors are replaced with essentially a
      // "plaintext" stand-in so that the code blocks will still get normal
      // css classes applied to them - and one bad language won't break the
      // entire highlighter
      lang = PLAINTEXT_LANGUAGE;
    }
    languages[name] = lang;
    restoreLanguageApi(lang);
    lang.rawDefinition = language.bind(null,hljs);

    if (lang.aliases) {
      lang.aliases.forEach(function(alias) {aliases[alias] = name;});
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  /*
    intended usage: When one language truly requires another

    Unlike `getLanguage`, this will throw when the requested language
    is not available.
  */
  function requireLanguage(name) {
    var lang = getLanguage(name);
    if (lang) { return lang; }

    var err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}',name));
    throw err;
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  function autoDetection(name) {
    var lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.requireLanguage = requireLanguage;
  hljs.autoDetection = autoDetection;
  hljs.inherit = inherit;
  hljs.debugMode = function() { SAFE_MODE = false; }

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit(
      {
        className: 'comment',
        begin: begin, end: end,
        contains: []
      },
      inherits || {}
    );
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' +
      '%|em|ex|ch|rem'  +
      '|vw|vh|vmin|vmax' +
      '|cm|mm|in|pt|pc|px' +
      '|deg|grad|rad|turn' +
      '|s|ms' +
      '|Hz|kHz' +
      '|dpi|dpcm|dppx' +
      ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      {
        begin: /\[/, end: /\]/,
        relevance: 0,
        contains: [hljs.BACKSLASH_ESCAPE]
      }
    ]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  var constants = [
    hljs.BACKSLASH_ESCAPE,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    hljs.PHRASAL_WORDS_MODE,
    hljs.COMMENT,
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    hljs.HASH_COMMENT_MODE,
    hljs.NUMBER_MODE,
    hljs.C_NUMBER_MODE,
    hljs.BINARY_NUMBER_MODE,
    hljs.CSS_NUMBER_MODE,
    hljs.REGEXP_MODE,
    hljs.TITLE_MODE,
    hljs.UNDERSCORE_TITLE_MODE,
    hljs.METHOD_GUARD
  ]
  constants.forEach(function(obj) { deepFreeze(obj); });

  // https://github.com/substack/deep-freeze/blob/master/index.js
  function deepFreeze (o) {
    Object.freeze(o);

    var objIsFunction = typeof o === 'function';

    Object.getOwnPropertyNames(o).forEach(function (prop) {
      if (o.hasOwnProperty(prop)
      && o[prop] !== null
      && (typeof o[prop] === "object" || typeof o[prop] === "function")
      // IE11 fix: https://github.com/highlightjs/highlight.js/issues/2318
      // TODO: remove in the future
      && (objIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true)
      && !Object.isFrozen(o[prop])) {
        deepFreeze(o[prop]);
      }
    });

    return o;
  };


  return hljs;
}));

</script>
<script>
  
hljs.registerLanguage('xml', /*
Language: HTML, XML
Website: https://www.w3.org/XML/
Category: common
*/

function(hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var XML_ENTITIES = {
    className: 'symbol',
    begin: '&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;'
  };
  var XML_META_KEYWORDS = {
	  begin: '\\s',
	  contains:[
	    {
	      className: 'meta-keyword',
	      begin: '#?[a-z_][a-z1-9_-]+',
	      illegal: '\\n',
      }
	  ]
  };
  var XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {begin: '\\(', end: '\\)'});
  var APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {className: 'meta-string'});
  var QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {className: 'meta-string'});
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: 'attr',
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: 'string',
            endsParent: true,
            variants: [
              {begin: /"/, end: /"/, contains: [XML_ENTITIES]},
              {begin: /'/, end: /'/, contains: [XML_ENTITIES]},
              {begin: /[^\s"'=<>`]+/}
            ]
          }
        ]
      }
    ]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist', 'wsf', 'svg'],
    case_insensitive: true,
    contains: [
      {
        className: 'meta',
        begin: '<![a-z]', end: '>',
        relevance: 10,
        contains: [
				  XML_META_KEYWORDS,
				  QUOTE_META_STRING_MODE,
				  APOS_META_STRING_MODE,
					XML_META_PAR_KEYWORDS,
					{
					  begin: '\\[', end: '\\]',
					  contains:[
						  {
					      className: 'meta',
					      begin: '<![a-z]', end: '>',
					      contains: [
					        XML_META_KEYWORDS,
					        XML_META_PAR_KEYWORDS,
					        QUOTE_META_STRING_MODE,
					        APOS_META_STRING_MODE
						    ]
			        }
					  ]
				  }
				]
      },
      hljs.COMMENT(
        '<!--',
        '-->',
        {
          relevance: 10
        }
      ),
      {
        begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
        relevance: 10
      },
      XML_ENTITIES,
      {
        className: 'meta',
        begin: /<\?xml/, end: /\?>/, relevance: 10
      },
      {
        begin: /<\?(php)?/, end: /\?>/,
        subLanguage: 'php',
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {begin: '/\\*', end: '\\*/', skip: true},
          {begin: 'b"', end: '"', skip: true},
          {begin: 'b\'', end: '\'', skip: true},
          hljs.inherit(hljs.APOS_STRING_MODE, {illegal: null, className: null, contains: null, skip: true}),
          hljs.inherit(hljs.QUOTE_STRING_MODE, {illegal: null, className: null, contains: null, skip: true})
        ]
      },
      {
        className: 'tag',
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending braket. The '$' is needed for the lexeme to be recognized
        by hljs.subMode() that tests lexemes outside the stream.
        */
        begin: '<style(?=\\s|>)', end: '>',
        keywords: {name: 'style'},
        contains: [TAG_INTERNALS],
        starts: {
          end: '</style>', returnEnd: true,
          subLanguage: ['css', 'xml']
        }
      },
      {
        className: 'tag',
        // See the comment in the <style tag about the lookahead pattern
        begin: '<script(?=\\s|>)', end: '>',
        keywords: {name: 'script'},
        contains: [TAG_INTERNALS],
        starts: {
          end: '\<\/script\>', returnEnd: true,
          subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
        }
      },
      {
        className: 'tag',
        begin: '</?', end: '/?>',
        contains: [
          {
            className: 'name', begin: /[^\/><\s]+/, relevance: 0
          },
          TAG_INTERNALS
        ]
      }
    ]
  };
}
);

hljs.registerLanguage('markdown', /*
Language: Markdown
Requires: xml.js
Author: John Crepezzi <john.crepezzi@gmail.com>
Website: https://daringfireball.net/projects/markdown/
Category: common, markup
*/

function(hljs) {
  return {
    aliases: ['md', 'mkdown', 'mkd'],
    contains: [
      // highlight headers
      {
        className: 'section',
        variants: [
          { begin: '^#{1,6}[ \\t]+', end: '$' },
          { begin: '^.+?\\n[=-]{2,}$' }
        ]
      },
      // inline html
      {
        begin: /<\/?[A-Za-z_]/, end: '>',
        subLanguage: 'xml',
        relevance: 0
      },
      // lists (indicators only), tasks: (- \\[[xX ]\\])
      {
        className: 'bullet',
        begin: '^\\s*((- \\[[xX ]\\])|[*+-]|(\\d+\\.))[ \\t]+'
      },
      // strong + emphasis (_**word**_, __*word*__, ___word___, *__word__*, **_word_**, ***word***)
      {
        className: 'bold-italic',
        variants: [
          { begin: '_\\*\\*.+?\\*\\*_' },
          { begin: '__\\*.+?\\*__' },
          { begin: '___.+?___' },
          { begin: '\\*__.+?__\\*' },
          { begin: '\\*\\*_.+?_\\*\\*' },
          { begin: '\\*\\*\\*.+?\\*\\*\\*' },
        ]
      },
      // strong segments
      {
        className: 'strong',
        begin: '[*_]{2}.*?[*_]{2}'
      },
      // emphasis segments
      {
        className: 'emphasis',
        variants: [
          { begin: '\\*.+?\\*' },
          { begin: '_.+?_', relevance: 0 }
        ]
      },
      // blockquotes
      {
        className: 'quote',
        begin: '^>[ \\t]+', end: '$'
      },
      // code snippets
      {
        className: 'code',
        variants: [
          {
            begin: '^```.*\\s*$', end: '^```[ ]*$'
          },
          {
            begin: '`.+?`'
          },
          {
            begin: '^( {4}|\\t)', end: '$',
            relevance: 0
          },
          {
            // https://plantuml.com/
            begin: '^@startuml$', end: '^@enduml$'
          },
          // {
          //   // use monospaced fonts for tables
          //   begin: '^(\\|[^\n]+\\|\r?\n)((?:\\| *:?[-]+:? *)+\\|)', end: '(\n(?:\\|[^\n]+\\|\r?\n?)*)?$'
          // },
          { begin: '\\$\\$', end: '\\$\\$' }
        ]
      },
      // horizontal rules
      {
        begin: '^[-\\*]{3,}', end: '$'
      },
      // wikilinks, E.g. [[Notes]]
      {
        begin: '\\[\\[.+?\\]\\]',
        returnBegin: true,
        contains: [
          {
            className: 'link',
            begin: '\\[\\[', end: '\\]\\]',
            excludeBegin: true, excludeEnd: true
          }
        ]
      },
      // using links - title and link
      {
        begin: '\\[.*?\\][\\(\\[].*?[\\)\\]]',
        returnBegin: true,
        contains: [
          {
            className: 'string',
            begin: '\\[', end: '\\]',
            excludeBegin: true,
            returnEnd: true,
            relevance: 0
          },
          {
            className: 'link',
            begin: '\\]\\(', end: '\\)',
            excludeBegin: true, excludeEnd: true
          },
          {
            className: 'symbol',
            begin: '\\]\\[', end: '\\]',
            excludeBegin: true, excludeEnd: true
          }
        ],
        relevance: 10
      },
      {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: 'symbol',
            begin: /\[/, end: /\]/,
            excludeBegin: true, excludeEnd: true
          },
          {
            className: 'link',
            begin: /:\s*/, end: /$/,
            excludeBegin: true
          }
        ]
      },
      // footnote, E.g. [^footnote]
      {
        begin: '\\[\\^.*\\]',
        returnBegin: true,
        contains: [
          {
            className: 'string',
            begin: '\\[', end: '\\]',
            excludeBegin: true, excludeEnd: true
          }
        ]
      },
      // highlighters
      {
        className: 'highlighter',
        begin: '==.+?=='
      },
      // hashtags
      {
        className: 'hashtag',
        // no \' to prevent markedText interruption
        begin: '(^|\\s)#[^!$%^&*()+|~=`{}\\[\\]:"<>?#@\\\\\\s;,.\uff1b\uff0c\u3002\ufe0f]+(?=\\s|;|,|\\.|\uff1b|\uff0c|\u3002|\ufe0f|$)'
      }
    ]
  };
}
);

hljs.registerLanguage('tex', /*
Language: TeX
Author: Vladimir Moskva <vladmos@gmail.com>
Website: https://www.latex-project.org
Category: markup
*/

function(hljs) {
  var COMMAND = {
    className: 'tag',
    begin: /\\/,
    relevance: 0,
    contains: [
      {
        className: 'name',
        variants: [
          {begin: /[a-zA-Z\u0430-\u044f\u0410-\u042f]+[*]?/},
          {begin: /[^a-zA-Z\u0430-\u044f\u0410-\u042f0-9]/}
        ],
        starts: {
          endsWithParent: true,
          relevance: 0,
          contains: [
            {
              className: 'string', // because it looks like attributes in HTML tags
              variants: [
                {begin: /\[/, end: /\]/},
                {begin: /\{/, end: /\}/}
              ]
            },
            {
              begin: /\s*=\s*/, endsWithParent: true,
              relevance: 0,
              contains: [
                {
                  className: 'number',
                  begin: /-?\d*\.?\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?/
                }
              ]
            }
          ]
        }
      }
    ]
  };

  return {
    contains: [
      COMMAND,
      {
        className: 'formula',
        contains: [COMMAND],
        relevance: 0,
        variants: [
          {begin: /\$\$/, end: /\$\$/},
          {begin: /\$/, end: /\$/}
        ]
      },
      hljs.COMMENT(
        '%',
        '$',
        {
          relevance: 0
        }
      )
    ]
  };
}
);

hljs.registerLanguage('plaintext', /*
Language: plaintext
Author: Egor Rogov (e.rogov@postgrespro.ru)
Description: Plain text without any highlighting.
Category: common
*/

function(hljs) {
    return {
        disableAutodetect: true
    };
}
);

hljs.registerLanguage('css', /*
Language: CSS
Category: common, css
Website: https://developer.mozilla.org/en-US/docs/Web/CSS
*/

function(hljs) {
  var FUNCTION_LIKE = {
    begin: /[\w-]+\(/, returnBegin: true,
    contains: [
      {
        className: 'built_in',
        begin: /[\w-]+/
      },
      {
        begin: /\(/, end: /\)/,
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.CSS_NUMBER_MODE,
        ]
      }
    ]
  }
  var ATTRIBUTE = {
    className: 'attribute',
    begin: /\S/, end: ':', excludeEnd: true,
    starts: {
      endsWithParent: true, excludeEnd: true,
      contains: [
        FUNCTION_LIKE,
        hljs.CSS_NUMBER_MODE,
        hljs.QUOTE_STRING_MODE,
        hljs.APOS_STRING_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        },
        {
          className: 'meta', begin: '!important'
        }
      ]
    }
  }
  var AT_IDENTIFIER = '@[a-z-]+' // @font-face
  var AT_MODIFIERS = "and or not only"
  var MEDIA_TYPES = "all print screen speech"
  var AT_PROPERTY_RE = /@\-?\w[\w]*(\-\w+)*/ // @-webkit-keyframes
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /(?:[A-Z\_\.\-]+|--[a-zA-Z0-9_-]+)\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [
      ATTRIBUTE
    ]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
      },
      {
        className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
      },
      {
        className: 'selector-attr',
        begin: /\[/, end: /\]?/, // ? to work around endless loop
        illegal: '$',
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
        ]
      },
      {
        className: 'selector-pseudo',
        begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: '@(page|font-face)',
        lexemes: AT_IDENTIFIER,
        keywords: '@page @font-face'
      },
      {
        begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
                                 // because it doesn’t let it to be parsed as
                                 // a rule set but instead drops parser into
                                 // the default mode which is how it should be.
        illegal: /:/, // break on Less variables @var: ...
        returnBegin: true,
        contains: [
          {
            className: 'keyword',
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/, endsWithParent: true, excludeEnd: true,
            relevance: 0,
            keywords: AT_MODIFIERS,
            contains: [
              {
                begin: /[a-z-]+:/,
                className:"attribute"
              },
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              hljs.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: 'selector-tag', begin: IDENT_RE,
        relevance: 0
      },
      {
        begin: '{', end: '}',
        illegal: /\S/,
        contains: [
          hljs.C_BLOCK_COMMENT_MODE,
          RULE,
        ]
      }
    ]
  };
}
);

hljs.registerLanguage('json', /*
Language: JSON / JSON with Comments
Description: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
Author: Ivan Sagalaev <maniac@softwaremaniacs.org>
Website: http://www.json.org
Category: common, protocols
*/

function(hljs) {
  var LITERALS = {literal: 'true false null'};
  var ALLOWED_COMMENTS = [
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE
  ]
  var TYPES = [
    hljs.QUOTE_STRING_MODE,
    hljs.C_NUMBER_MODE
  ];
  var VALUE_CONTAINER = {
    end: ',', endsWithParent: true, excludeEnd: true,
    contains: TYPES,
    keywords: LITERALS
  };
  var OBJECT = {
    begin: '{', end: '}',
    contains: [
      {
        className: 'attr',
        begin: /"/, end: /"/,
        contains: [hljs.BACKSLASH_ESCAPE],
        illegal: '\\n',
      },
      hljs.inherit(VALUE_CONTAINER, {begin: /:/})
    ].concat(ALLOWED_COMMENTS),
    illegal: '\\S'
  };
  var ARRAY = {
    begin: '\\[', end: '\\]',
    contains: [hljs.inherit(VALUE_CONTAINER)], // inherit is a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents
    illegal: '\\S'
  };
  TYPES.push(OBJECT, ARRAY);
  ALLOWED_COMMENTS.forEach(function(rule) {
    TYPES.push(rule)
  })
  return {
    contains: TYPES,
    keywords: LITERALS,
    illegal: '\\S'
  };
}
);

hljs.registerLanguage('javascript', /*
Language: JavaScript
Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
Category: common, scripting
Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
*/

function(hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword:
      'in of if for while finally var new function do return void else break catch ' +
      'instanceof with throw case default try this switch continue typeof delete ' +
      'let yield const export super debugger as async await static ' +
      // ECMAScript 6 modules import
      'import from as'
    ,
    literal:
      'true false null undefined NaN Infinity',
    built_in:
      // jsbox: begin
      'JSBox ' +
      'exports setTimeout setInterval clearInterval alert ' +
      '$device $app $context $ui $clipboard $http $file $photo $audio $cache $keychain $thread $share $push $location $system $message $calendar $reminder $contact $motion $input $text $picker $qrcode $pdf $detector $quicklook $drive $safari $archiver $timer $console $addin $browser $keyboard $network $ssh $widget $sqlite $socket $server $intents $xml $editor $prefs $nodejs $jsbox $imagekit $actions btoa atob $include $l10n $delay $wait $rect $size $point $insets $color $rgb $rgba $font $range $indexPath $transform $image $data $icon $labeledValue $accessibilityAction $props $defc $block $delegate $objc $objc_retain $objc_release $objc_clean $define_struct $struct $get_protocol $define $protocol $env $align $cellInset $contentMode $btnType $zero $layout $lineCap $lineJoin $mediaType $imgPicker $kbType $assetMedia $pageSize $UIEvent $stackViewAxis $stackViewDistribution $stackViewAlignment $stackViewSpacing $collect_garbage ' +
      'NSDictionary NSMutableDictionary NSArray NSMutableArray NSSet NSMutableSet NSString NSMutableString NSData NSMutableData NSNumber NSURL NSEnumerator ' +
      'ObjCProxy ObjCDefineClass ObjCDefineProtocol ObjCDefineCFunc ObjCDefineStruct ObjCGetProtocol ObjCBlock ObjCDelegate ObjCRetain ObjCRelease ObjCClean ' +
      // jsbox: end
      'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' +
      'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' +
      'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' +
      'TypeError URIError Number Math Date String RegExp Array Float32Array ' +
      'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' +
      'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' +
      'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' +
      'Promise'
  };
  var NUMBER = {
    className: 'number',
    variants: [
      { begin: '\\b(0[bB][01]+)n?' },
      { begin: '\\b(0[oO][0-7]+)n?' },
      { begin: hljs.C_NUMBER_RE + 'n?' }
    ],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: []  // defined later
  };
  var HTML_TEMPLATE = {
    begin: 'html`', end: '',
    starts: {
      end: '`', returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'xml',
    }
  };
  var CSS_TEMPLATE = {
    begin: 'css`', end: '',
    starts: {
      end: '`', returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'css',
    }
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  SUBST.contains = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER,
    hljs.REGEXP_MODE
  ];
  var PARAMS_CONTAINS = SUBST.contains.concat([
    hljs.C_BLOCK_COMMENT_MODE,
    hljs.C_LINE_COMMENT_MODE
  ]);

  return {
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: KEYWORDS,
    contains: [
      {
        className: 'meta',
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      },
      {
        className: 'meta',
        begin: /^#!/, end: /$/
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      hljs.C_LINE_COMMENT_MODE,
      hljs.COMMENT(
        '/\\*\\*',
        '\\*/',
        {
          relevance : 0,
          contains : [
            {
              className : 'doctag',
              begin : '@[A-Za-z]+',
              contains : [
                {
                  className: 'type',
                  begin: '\\{',
                  end: '\\}',
                  relevance: 0
                },
                {
                  className: 'variable',
                  begin: IDENT_RE + '(?=\\s*(-)|$)',
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                },
              ]
            }
          ]
        }
      ),
      hljs.C_BLOCK_COMMENT_MODE,
      NUMBER,
      { // object attr container
        begin: /[{,\n]\s*/, relevance: 0,
        contains: [
          {
            begin: IDENT_RE + '\\s*:', returnBegin: true,
            relevance: 0,
            contains: [{className: 'attr', begin: IDENT_RE, relevance: 0}]
          }
        ]
      },
      { // "value" container
        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.REGEXP_MODE,
          {
            className: 'function',
            begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: IDENT_RE
                  },
                  {
                    begin: /\(\s*\)/,
                  },
                  {
                    begin: /\(/, end: /\)/,
                    excludeBegin: true, excludeEnd: true,
                    keywords: KEYWORDS,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            className: '',
            begin: /\s/,
            end: /\s*/,
            skip: true,
          },
          { // E4X / JSX
            begin: /</, end: /(\/[A-Za-z0-9\\._:-]+|[A-Za-z0-9\\._:-]+\/)>/,
            subLanguage: 'xml',
            contains: [
              { begin: /<[A-Za-z0-9\\._:-]+\s*\/>/, skip: true },
              {
                begin: /<[A-Za-z0-9\\._:-]+/, end: /(\/[A-Za-z0-9\\._:-]+|[A-Za-z0-9\\._:-]+\/)>/, skip: true,
                contains: [
                  { begin: /<[A-Za-z0-9\\._:-]+\s*\/>/, skip: true },
                  'self'
                ]
              }
            ]
          }
        ],
        relevance: 0
      },
      {
        className: 'function',
        beginKeywords: 'function', end: /\{/, excludeEnd: true,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {begin: IDENT_RE}),
          {
            className: 'params',
            begin: /\(/, end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            contains: PARAMS_CONTAINS
          }
        ],
        illegal: /\[|%/
      },
      {
        begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      },
      hljs.METHOD_GUARD,
      { // ES6 class
        className: 'class',
        beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
        illegal: /[:"\[\]]/,
        contains: [
          {beginKeywords: 'extends'},
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: 'constructor get set', end: /\{/, excludeEnd: true
      }
    ],
    illegal: /#(?!!)/
  };
}
);

  if (false) {
    hljs.initHighlightingOnLoad();
  } else {
    document.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll("pre code").forEach(block => {
        if (block.className.indexOf("language-") === -1) {
          block.classList.add("language-plaintext");
        }
        hljs.highlightBlock(block);
      });
    });
  }
</script>
  <script>
    if (true) {
      MathJax = {
        loader: { load: ["[tex]/upgreek"] },
        showProcessingMessages: false,
        tex: {
          packages: { "[+]": ["upgreek"] },
          autoload: {
            upgreek: [
              'upalpha', 'upbeta', 'upchi', 'updelta', 'Updelta', 'upepsilon',
              'upeta', 'upgamma', 'Upgamma', 'upiota', 'upkappa', 'uplambda',
              'Uplambda', 'upmu', 'upnu', 'upomega', 'Upomega', 'upomicron',
              'upphi', 'Upphi', 'uppi', 'Uppi', 'uppsi', 'Uppsi', 'uprho',
              'upsigma', 'Upsigma', 'uptau', 'uptheta', 'Uptheta', 'upupsilon',
              'Upupsilon', 'upvarepsilon', 'upvarphi', 'upvarpi', 'upvarrho',
              'upvarsigma', 'upvartheta', 'upxi', 'Upxi', 'upzeta',
            ]
          },
          inlineMath: [],
          processEscapes: true
        },
        tex2jax: {
          inlineMath: [],
          processEscapes: true
        },
        svg: {
          fontCache: "global"
        }
      };

      const script = document.createElement("script");
      script.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.min.js";
      script.defer = true;
      const anchor = document.getElementsByTagName("script")[0];
      anchor.parentNode.insertBefore(script, anchor);
    }
  </script>
</head>
<body>
  <article class="markdown-body"><h1>金融短视频创作平台商业计划书</h1>
<h2>一、项目概述</h2>
<h3>项目名称：</h3>
<ul>
<li>金融短视频创作平台</li>
</ul>
<h3>项目简介：</h3>
<ul>
<li>该项目是一个专业的金融短视频创作平台，为金融机构、金融从业者、金融爱好者提供高效、便捷、有趣的短视频制作工具和服务，帮助他们在抖音、快手等主流短视频平台上进行金融内容的传播和营销。该平台利用人工智能技术和数据分析，为用户提供丰富的金融短视频模板、素材、功能等，让用户可以轻松地制作出高质量、高效果的金融短视频。</li>
</ul>
<h3>项目目标：</h3>
<ul>
<li>该项目的目标是成为国内领先的金融短视频创作平台，打造一个全球化的金融短视频社区，为用户提供优质的金融短视频内容，为合作伙伴提供有效的金融短视频营销方案，为投资者提供可观的回报。</li>
</ul>
<h2>二、项目亮点</h2>
<h3>专业性：</h3>
<ul>
<li>该平台专注于金融领域的短视频创作，提供了针对金融主题和风格的专业化模板和素材，让用户可以制作出符合金融行业和市场的短视频内容。</li>
</ul>
<h3>智能性：</h3>
<ul>
<li>该平台利用人工智能技术和数据分析，为用户提供了智能化的短视频生成器和编辑器，让用户可以通过简单的输入或操作，就能生成出高质量、高效果的金融短视频。</li>
</ul>
<h3>趣味性：</h3>
<ul>
<li>该平台注重用户体验和互动，为用户提供了有趣的短视频功能和活动，让用户可以在制作和观看金融短视频时享受乐趣和收益。</li>
</ul>
<h3>合作性：</h3>
<ul>
<li>该平台建立了与各类金融机构、金融从业者、金融爱好者等合作伙伴的合作关系，为用户提供了丰富、多样、有价值的金融短视频内容和活动，实现资源共享和互利共赢。</li>
</ul>
<h2>三、市场分析</h2>
<h3>市场规模：</h3>
<ul>
<li>金融短视频市场规模近年来呈现高速增长的态势，受益于移动互联网的普及和短视频行业的发展。根据艾媒咨询 的数据，2020 年中国金融短视频市场规模达到了 1200 亿元，同比增长了 120%；2021 年中国金融短视频市场规模达到了 2100 亿元，同比增长了 75%。根据 Mob 研究院 的预测，2023 年中国短视频市场规模将达到 3000 亿元，其中金融短视频占比约为 10%，即约为 300 亿元。这些数据表明，金融短视频市场有着巨大的潜力和前景。</li>
</ul>
<h3>市场需求：</h3>
<ul>
<li>金融短视频市场需求主要来自于三类用户：金融机构、金融从业者、金融爱好者。他们对于优质的财经内容有着强烈的需求和偏好，同时也希望通过短视频来展示自己的品牌、专业、个性等。然而，目前市场上缺乏专业的金融短视频创作平台，用户在制作和发布金融短视频时面临着内容素材、技术水平、时间成本等方面的困难和挑战。因此，我们的项目旨在打造一个专业的金融短视频创作平台，为用户提供高效、便捷、有趣的短视频制作工具和服务。</li>
</ul>
<h3>市场竞争：</h3>
<ul>
<li>金融短视频市场竞争格局目前以抖音和快手为主导，两者在内容形式、用户画像、商业模式等方面存在差异。抖音更注重内容的专业性和教育性，用户更偏向于中高收入、高学历、高消费的群体，商业模式以电商和广告为主。快手更注重内容的娱乐性和互动性，用户更偏向于低收入、低学历、低消费的群体，商业模式以直播和广告为主。除此之外，还有一些针对特定行业或领域的短视频创作平台，如 FlexClip、火山小视频等，它们提供了一些定制化的模板和功能，但是针对金融领域的服务还不够丰富和深入。我们的项目将填补这一市场空白，并利用我们在金融领域的专业知识和人工智能技术，在产品功能、内容创新和营销手段等方面形成自己的核心竞争力。</li>
</ul>
<h2>四 、产品定位</h2>
<p>该项目定位为一个专业的金融短视频创作平台，为用户提供高效、便捷、有趣的短视频制作工具和服务，帮助他们在抖音、快手等主流短视频平台上进行金融内容的传播和营销。该平台利用人工智能技术和数据分析，为用户提供丰富的金融短视频模板、素材、功能等，让用户可以轻松地制作出高质量、高效果的金融短视频。</p>
<h2>五、产品功能</h2>
<p>该项目的核心功能包括以下几个方面：</p>
<ul>
<li><strong>内置的金融短视频模板库</strong>，提供各种金融主题和风格的短视频模板，用户可以根据自己的需求和喜好选择和编辑。例如，有关于股票、基金、期货、外汇、保险、信用卡等各类金融产品或服务的介绍、评价、推荐等模板；有关于财经新闻、市场分析、投资策略、理财技巧等各类金融话题或内容的报道、解读、讲解等模板；有关于个人财富、企业财务、国家经济等各类金融案例或故事的展示、分享、启发等模板。这些模板都经过了专业的设计和优化，符合短视频的特点和规范，具有高度的可视化和可操作性。</li>
<li><strong>智能的金融短视频生成器</strong>，用户可以输入金融的内容或关键词，让 AI 一键生成一个金融短视频，无需复杂的操作和技巧。该功能利用了自然语言处理和图像识别等人工智能技术，能够根据用户的输入自动匹配合适的模板和素材，生成出符合用户意图和风格的金融短视频。该功能可以大大提高用户的制作效率和便捷性。</li>
<li><strong>丰富的金融短视频素材库</strong>，提供各种金融相关的图片、音乐、字幕、特效等素材，用户可以自由地添加和调整。该功能利用了数据挖掘和数据分析等人工智能技术，能够根据用户的选择和喜好推荐合适的素材，提升用户的制作体验和效果。该功能可以大大丰富用户的制作内容和创意。</li>
<li><strong>强大的金融短视频编辑器</strong>，提供各种专业的短视频编辑功能，如剪辑、合成、滤镜、转场、配音等，用户可以根据自己的创意和需求进行个性化的编辑。该功能利用了图像处理和音频处理等人工智能技术，能够根据用户的操作自动优化视频的质量和效果，提高用户的制作水平和满意度。该功能可以大大增强用户的制作自由度和趣味性。</li>
<li><strong>便捷的金融短视频发布器</strong>，支持一键发布到抖音、快手等主流短视频平台，用户可以方便地管理和分享自己的金融短视频作品。该功能利用了社交媒体和网络传播等人工智能技术，能够根据用户的目标和场景自动调整视频的格式和参数，提升用户的发布效率和效果。该功能可以大大扩大用户的发布范围和影响力。</li>
</ul>
<h2>六、盈利模式</h2>
<p>该项目的主要盈利模式有以下几种：</p>
<ul>
<li><strong>广告收入</strong>：在平台上展示相关的金融产品或服务的广告，从广告主收取费用。该模式可以利用平台上积累的大量用户数据和行为数据，为广告主提供精准的投放和效果评估，提高广告的转化率和回报率。</li>
<li><strong>会员收入</strong>：为用户提供付费会员服务，会员用户可以享受更多的模板、素材、功能等优惠和特权。该模式可以利用平台上提供的丰富和专业的金融短视频内容和服务，吸引用户付费订阅，提高用户的忠诚度和留存率。</li>
<li><strong>服务收入</strong>：为合作伙伴提供定制化的金融短视频制作和营销服务，从合作伙伴收取服务费用。该模式可以利用平台上拥有的专业的金融短视频制作团队和人工智能技术，为合作伙伴提供高质量、高效果的金融短视频解决方案，满足合作伙伴的个性化需求和目标。</li>
<li><strong>数据收入</strong>：利用平台上积累的大量用户数据和行为数据，为合作伙伴提供数据分析和咨询服务，从合作伙伴收取数据费用。该模式可以利用平台上拥有的强大的数据挖掘和数据分析能力，为合作伙伴提供有价值的数据洞察和建议，帮助合作伙伴优化自己的金融产品或服务。</li>
</ul>
<h2>七、营销策略</h2>
<p>该项目的主要营销策略有以下几种：</p>
<ul>
<li><strong>内容营销</strong>：通过在抖音、快手等平台上发布优质的金融短视频内容，吸引用户关注和转化，提高平台的知名度和影响力。该策略可以利用平台上提供的专业的金融短视频模板、素材、功能等，让用户可以轻松地制作出高质量、高效果的金融短视频，并通过社交媒体和网络传播等手段，扩大内容的覆盖范围和受众群体。</li>
<li><strong>口碑营销</strong>：通过鼓励用户分享和推荐平台给他人，形成良好的口碑效应，扩大平台的用户群体和忠诚度。该策略可以利用平台上提供的有趣有料的金融短视频内容和活动，让用户在制作和观看金融短视频时享受乐趣和收益，并通过奖励机制和社交网络等手段，激发用户的分享欲望和行为。</li>
<li><strong>合作营销</strong>：通过与各类金融机构、金融从业者、金融爱好者等合作伙伴建立合作关系，共同打造金融短视频内容和活动，实现资源共享和互利共赢。该策略可以利用平台上拥有的专业的金融短视频制作团队和人工智能技术，为合作伙伴提供定制化的金融短视频制作和营销服务，并通过平台上提供的丰富、多样、有价值的金融短视频内容和活动，吸引和留住用户，增加用户的参与度和粘性。</li>
<li><strong>活动营销</strong>：通过举办各种有趣有料的金融短视频相关的活动，如比赛、抽奖、直播等，增加用户的参与度和粘性。该策略可以利用平台上提供的强大的金融短视频编辑器和发布器，让用户可以方便地参与和创建金融短视频相关的活动，并通过奖品、荣誉、互动等手段，激发用户的兴趣和情感。</li>
</ul>
<h2>八、技术风险</h2>
<p>该项目依赖于 AI 技术和数据分析的支持，可能会遇到以下几种技术风险：</p>
<ul>
<li><strong>数据安全风险</strong>：平台上涉及到用户的个人信息和金融信息，可能会受到黑客的攻击或泄露，导致用户的隐私和财产受到损失。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用加密、防火墙、验证码等技术手段，保护平台和用户的数据安全。</li>
<li>采用分级、分权、分区等管理制度，限制平台内部人员对用户数据的访问和使用。</li>
<li>采用备份、恢复、审计等应急措施，应对可能发生的数据丢失或泄露事件。</li>
</ul>
</li>
<li><strong>数据质量风险</strong>：平台上使用的数据可能会存在不准确、不完整、不及时等问题，影响 AI 技术的效果和用户体验。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用数据清洗、数据校验、数据更新等技术手段，保证平台使用的数据质量。</li>
<li>采用数据来源、数据标注、数据反馈等管理制度，保证平台获取的数据可靠性。</li>
<li>采用数据测试、数据监控、数据优化等改进措施，保证平台提升的数据效果。</li>
</ul>
</li>
<li><strong>技术更新风险</strong>：AI 技术和数据分析是一个快速发展的领域，可能会出现更先进或更适合的技术或方法，导致平台的技术落后或失效。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用技术研究、技术引进、技术合作等技术手段，保持平台的技术领先和创新。</li>
<li>采用技术培训、技术交流、技术激励等管理制度，保持平台内部人员的技术水平和动力。</li>
<li>采用技术升级、技术迁移、技术兼容等变更措施，保持平台的技术稳定和适应。</li>
</ul>
</li>
</ul>
<h2>九、市场风险</h2>
<p>该项目面对着激烈的市场竞争和变化，可能会遇到以下几种市场风险：</p>
<ul>
<li><strong>用户需求风险</strong>：用户对于金融短视频的需求可能会随着时间、地点、事件等因素发生变化或下降，导致平台的用户量和活跃度下降。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用用户调研、用户分析、用户反馈等市场手段，及时了解和满足用户的需求和偏好。</li>
<li>采用用户细分、用户定位、用户画像等市场制度，准确把握和服务用户的特征和目标。</li>
<li>采用用户留存、用户激励、用户增长等市场措施，持续提高和扩大用户的忠诚度和规模。</li>
</ul>
</li>
<li><strong>用户口碑风险</strong>：用户对于平台的评价可能会受到平台自身或外部因素的影响而发生变化或下滑，导致平台的声誉和信任度下降。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用用户评价、用户监督、用户投诉等市场手段，及时收集和处理用户的意见和建议。</li>
<li>采用用户满意、用户赞赏、用户荣誉等市场制度，不断提升和展示用户的体验和感受。</li>
<li>采用用户分享、用户推荐、用户联盟等市场措施，积极培养和传播用户的口碑和影响力。</li>
</ul>
</li>
<li><strong>竞争对手风险</strong>：市场上可能会出现更强或更专业的竞争对手，导致平台的市场份额和优势下降。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用竞争分析、竞争对策、竞争合作等市场手段，密切关注和应对竞争对手的动态和策略。</li>
<li>采用竞争差异、竞争优势、竞争壁垒等市场制度，明确区分和突出自己的特色和价值。</li>
<li>采用竞争挑战、竞争创新、竞争超越等市场措施，不断提高和优化自己的产品和服务。</li>
</ul>
</li>
</ul>
<h2>十、法律风险</h2>
<p>该项目涉及到金融领域的相关法律法规和政策，可能会遇到以下几种法律风险：</p>
<ul>
<li><strong>版权风险</strong>：平台上使用的金融短视频内容或素材可能会侵犯他人的版权或知识产权，导致平台被起诉或罚款。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用版权申请、版权授权、版权标注等法律手段，保证平台使用的内容或素材有合法的来源和许可。</li>
<li>采用版权检测、版权监督、版权维护等法律制度，保证平台使用的内容或素材不侵犯他人的权利和利益。</li>
<li>采用版权教育、版权协商、版权赔偿等法律措施，保证平台在发生版权纠纷时能够及时解决和处理。</li>
</ul>
</li>
<li><strong>监管风险</strong>：平台上发布的金融短视频内容或广告可能会违反国家或地区的金融监管规定或要求，导致平台被查处或封禁。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用监管遵守、监管申报、监管沟通等法律手段，保证平台发布的内容或广告符合相关的法律法规和政策要求。</li>
<li>采用监管审核、监管反馈、监管改进等法律制度，保证平台发布的内容或广告及时纠正和优化。</li>
</ul>
</li>
<li>采用监管培训、监管协作、监管应对等法律措施，保证平台在遇到监管问题时能够有效应对和解决。</li>
<li><strong>税务风险</strong>：平台上的收入或支出可能会受到不同国家或地区的税务政策或制度的影响，导致平台的税负增加或税务纠纷。为了防范这一风险，我们将采取以下措施：
<ul>
<li>采用税务规划、税务申报、税务缴纳等法律手段，保证平台合理合法地处理自己的税务事项。</li>
<li>采用税务核算、税务审计、税务报告等法律制度，保证平台准确完整地记录和反映自己的税务情况。</li>
<li>采用税务咨询、税务协商、税务调解等法律措施，保证平台在发生税务争议时能够及时沟通和解决。</li>
</ul>
</li>
</ul>
<h2>十一  、项目优势</h2>
<p>该项目具有以下几个方面的优势：</p>
<ul>
<li>市场优势：该项目填补了市场空白，为用户提供了专业的金融短视频创作平台，满足了用户对于优质金融内容的需求和偏好。根据艾媒咨询 的数据，2020 年中国金融短视频市场规模达到了 1200 亿元，同比增长了 120%；2021 年中国金融短视频市场规模达到了 2100 亿元，同比增长了 75%。根据 Mob 研究院 的预测，2023 年中国短视频市场规模将达到 3000 亿元，其中金融短视频占比约为 10%，即约为 300 亿元。这些数据表明，金融短视频市场有着巨大的潜力和前景。</li>
<li>技术优势：该项目利用了 AI 技术和数据分析，为用户提供了高效、便捷、有趣的金融短视频制作工具和服务，提高了用户的制作效率和体验。该项目的核心功能包括内置的金融短视频模板库、智能的金融短视频生成器、丰富的金融短视频素材库、强大的金融短视频编辑器、便捷的金融短视频发布器等，这些功能都利用了自然语言处理、图像识别、图像处理、音频处理、数据挖掘、数据分析等人工智能技术，能够根据用户的输入、选择、操作等自动匹配、生成、优化、发布金融短视频。</li>
<li>内容优势：该项目建立了与各类金融机构、金融从业者、金融爱好者等合作伙伴的合作关系，为用户提供了丰富、多样、有价值的金融短视频内容和活动。该项目的主要内容包括各类金融产品或服务的介绍、评价、推荐等；各类金融话题或内容的报道、解读、讲解等；各类金融案例或故事的展示、分享、启发等。这些内容都经过了专业的设计和优化，符合短视频的特点和规范，具有高度的可视化和可操作性。</li>
<li>团队优势：该项目拥有了一个专业、创新、合作的团队，为项目提供了强大的人才支持和保障。该团队由来自不同领域和背景的人才组成，包括金融专家、AI 工程师、数据分析师、UI 设计师、产品经理等。这些人才都具有丰富的经验和能力，在各自的领域有着卓越的表现和成就。他们共同为项目贡献了自己的智慧和创意，并通过良好的沟通和协作，实现了项目的高效和优质的开发和运营。</li>
</ul>
<h2>十二 、项目展望</h2>
<p>该项目有着广阔的发展前景和潜力，期望在未来实现以下几个方面的目标：</p>
<ul>
<li>国内领先：成为国内领先的金融短视频创作平台，为用户提供优质的金融短视频内容，为合作伙伴提供有效的金融短视频营销方案，为投资者提供可观的回报。该目标可以通过以下几个方面来实现：
<ul>
<li>提升平台的用户量和活跃度，通过内容营销、口碑营销、合作营销、活动营销等策略，吸引和留住更多的用户，提高用户的参与度和粘性。</li>
<li>提升平台的收入和利润，通过广告收入、会员收入、服务收入、数据收入等模式，增加和多元化平台的收入来源，降低和控制平台的成本支出。</li>
<li>提升平台的品牌和影响力，通过用户评价、用户监督、用户投诉等手段，及时收集和处理用户的意见和建议，不断提升和展示用户的体验和感受，积极培养和传播用户的口碑和影响力。</li>
<li>国际化：扩展到国际市场，为全球用户提供多语言、多货币、多文化的金融短视频创作平台，打造一个全球化的金融短视频社区，为用户提供一个交流、学习、娱乐的平台，促进金融知识和文化的传播和交流。该目标可以通过以下几个方面来实现：</li>
<li>适应不同国家或地区的市场需求和法律法规，通过市场调研、市场分析、市场反馈等手段，及时了解和满足不同国家或地区用户的需求和偏好，符合相关的法律法规和政策要求。</li>
<li>支持不同国家或地区的语言和货币，通过语言翻译、语言识别、货币兑换等手段，为不同国家或地区用户提供方便快捷的语言和货币服务，消除语言和货币方面的障碍。</li>
<li>融合不同国家或地区的文化和习惯，通过文化研究、文化交流、文化尊重等手段，为不同国家或地区用户提供多样化和有趣化的文化体验，增加文化方面的吸引力。</li>
<li>多元化：探索更多的金融短视频应用场景和商业模式，为用户提供更多的金融短视频产品和服务，满足用户的多元化需求和偏好。该目标可以通过以下几个方面来实现：</li>
<li>开发更多的金融短视频功能和内容，通过技术研究、技术引进、技术合作等手段，保持平台的技术领先和创新；通过内容设计、内容优化、内容创新等手段，保持平台的内容丰富和专业。</li>
</ul>
</li>
<li>拓展更多的金融短视频领域和主题，通过行业分析、行业对策、行业合作等手段，密切关注和应对不同行业或领域的金融动态和机遇。例如，可以关注和涉及以下几个方面的金融短视频内容：
<ul>
<li>与新兴技术或产业相关的金融短视频，如区块链、人工智能、云计算、5 G、物联网等，介绍或评价这些技术或产业的发展趋势、市场规模、投资机会、风险挑战等。</li>
<li>与社会热点或事件相关的金融短视频，如新冠疫情、贸易战、气候变化、奥运会等，报道或解读这些热点或事件对于金融市场、金融政策、金融产品等的影响和启示。</li>
<li>与个人生活或消费相关的金融短视频，如旅游、教育、健康、娱乐等，分享或推荐这些生活或消费领域的金融产品或服务，如旅游保险、教育贷款、健康理财、娱乐投资等。</li>
<li>与国际视野或文化相关的金融短视频，如世界各国或地区的经济情况、金融制度、金融习惯等，展示或比较这些国际视野或文化方面的金融知识和特色，增加用户的全球化意识和视角。</li>
</ul>
</li>
</ul>
</article>
  
  
  
  
</body>
<script>
  // Translate vectors to <object> to properly use online fonts
  const images = document.querySelectorAll("img");
  images.forEach(image => {
    const source = image.src;
    if (source.includes("image/svg+xml") || source.toLowerCase().endsWith(".svg")) {
      const object = document.createElement("object");
      object.setAttribute("data", source);
      image.parentNode.replaceChild(object, image);
    }
  });
</script>
<style>
  
</style>
<script>
  // Learn more: https://docs.taio.app/#/editor/custom-preview
window.addEventListener("load", event => {
  
});
</script>
</html>